//#include <iostream>
//
//using namespace std;
//
//int main()
//{
//	double pi_d = 3.14159265358979323846264338327950288;
//	float pi_f = 3.14f;	//f안붙이면 d로 생각해서 경고뜸
//
//	cout << pi_d << endl;//6자리 이하는 최적화함
//	cout << pi_f << endl;
//	cout << "------------" << endl;
//
//
//	long i = 0x4048f5c3;//3.14
//	float bitFloatHack = * (float *) &i;
//	/*
//	* &i : i의 주소
//	* (float *) : 에 있는 값(비트 단위로)을 float 형식의 값으로.   
//	* * : 그 주소의 값을 저장함
//	*
//	* 
//	* long : 4바이트, float : 4바이트 -> 메모리 크기에선 문제가 발생하지 않는다.
//	* 
//	* 
//	* 정수형 변수를 실수형 변수로 막 바꿔도 되는건가? 다음을 알아봅시다.
//	* 
//	* long :
//	* left most bit : sign bit
//	* 나머지 bit : 값을 저장하는 비트
//	*	-> 정수형 변수
//	*
//	*
//	* 
//	* float : 실수형 변수
//	*		□			   □□□□□□□□				□□□□□□□□□□□□□□□□□□□□□□□
//	*  sign: 1bit			Exponent: 8bit								Mantissa: 23bit
//	* 
//	* 일단 이 내용을 보기만 하고 다음 내용을 읽어봅시다
//	* 
//	* 사람은 1000000000000000같은 큰 수를 간단하게 읽기 위해 다음과 같이 축약합니다
//	* 1000000000000000 = 1.0*10^15 = 1E+15
//	* 
//	* 이와 마찬가지의 방식을 컴퓨터에 적용해봅시다.
//	* 하지만 컴퓨터는 이진수로 작동하기 때문에 십진수 체계의 지수를 사용하기 불편합니다. 따라서 2^n형태로 축약하게 됩니다.
//	* 
//	* #.# * 2^#
//	* 예를 들어, 2를 float로 표현한다면 다음과 같습니다
//	* 
//	*		□			   ■□□□□□□□				□□□□□□□□□□□□□□□□□□□□□□□
//	*  sign: 1bit			Exponent: 8bit								Mantissa: 23bit
//	* 
//	* 모든 비트가 0이 아니라면, 기본적으로 1.0은 주어집니다.
//	* 
//	* 따라서 값은 다음과 같이 표현됩니다.
//	* 1.0 * 2^1
//	* 
//	* 위의 Exponent 최 좌측 비트가 1상태인 것이 보이나요?
//	* 저 부분이 2^1의 지수부를 형성합니다. Exponent도 정상적으로 우측부터 비트가 차오르긴 합니다.
//	* 다만, 2^-10같은 연산들도 수행하기 위해 exponent 값을 다음과 같은 방식으로 저장합니다.
//	* 
//	* 
//	* -> float의 지수부 길이 : 8 (이 값이 k)
//	* -> bias = 2^(k-1)-1
//	* -> bias + 원하는 exponent값  =>  bit representation
//	*	-> bit representation - bias => 실제로 계산하는 exponent값
//	* 
//	* 따라서 2^1은 exponent 값이 1이었지만, 127 + 1 = 128이기 때문에 bit에는 최좌측(2^7 bit)만 On 된 것입니다.
//	* 저 bit를 컴퓨터에서 계산에 이용할 땐, 128 "- 127" = 1 이렇게 사용하게 됩니다.
//	* 
//	* 아무튼 저 exponent bit로 표현된 값에서 127을 뺀 값이 우리가 원하는 값입니다.
//	* 
//	* 
//	* 
//	* 이제 3.14를 표현해봅시다.
//	* 딱 봐도 지수부만 이용해선 어림도 없지 않은가요?
//	* 
//	* 일단 3.14를 2의 n승으로 분리해봅시다
//	* 
//	* 3.14 = 2^1 * 1.57
//	* 
//	* 이를 보면 sign bit : 0
//	* exponent bit : 128 [1000 0000]
//	* Mantissa : ???
//	* 
//	* 이제 1.57만 Mantissa에서 구해주면 됩니다.
//	* Mantissa는 "가수"라고 부르며 위에서 1.0의 뒷부분인, 0.###부분을 담당합니다.
//	* 
//	* Mantissa는 다음과 같이 작동합니다.
//	* 1.57에서 1.0은 기본으로 제공됩니다. (float 값의 모든 bit가 0이 아닌 이상)
//	* 0.57만 따로 구합니다.
//	* Mantissa의 최 좌측 bit는 2^-1 = 0.5 이다
//	* 다음 bit는 2^-2 = 0.25 이다
//	* 다음은 0.125, 0.0625 ......
//	* 이 값들을 조합해서 0.57과 가장 비슷한 값을 만들어야 합니다.
//	* 
//	* 다음 엑셀 파일은 직접 버튼으로 값을 만들어 볼 수 있는 엑셀입니다.
//	* 한번 3.14를 만들어보세요! (3.14159가 미리 만들어져있습니다)
//	* 
//	* https://lemontrivia.tistory.com/34
//	* 
//	* 근데 좀 골때리는 문제가 있습니다.
//	* 실제로 0.57은 만들 수 없고 그에 근접한 값만 만들 수 있는데, 거기서 좀 아리까리해집니다.
//	* 
//	* 0.5700000000003
//	* 0.5699999999996
//	* 
//	* 우리가 원하는 값이랑 더 가까우니까 이 두 수 중 0.5700..003이 좋은 것이 분명합니다.근데 안해보고는 모릅니다.
//	* 이 부분은 컴퓨터가 알아서 더 가까운 값을 찾아줍니다.
//	* 그렇게 해서 최종적으로 나온 값을 컴퓨터가 알아서 절삭해줍니다. 대부분 소수점 여섯 번째 자리를 잘라버립니다.
//	* 
//	* 이런 과정을 거치기 때문에 정수형 변수에 비해 실수형 변수 사용을 지양해야 하는 것입니다.
//	* 1. 오차 누적
//	* 2. 연산 비효율
//	* 
//	* 이정도만 알아도 충분한 것 같은데... 더 많은 정보가 필요하신 분은 "IEEE 754 pdf"키워드를 검색해보세요
//	* 
//	* 아무튼 만들어진 float 변수의 3.14 값은 다음의 bit representation을 가집니다
//	* 
//	*		□			   ■□□□□□□□				■□□■□□□■■■■□■□■■■□□□□■■
//	*  sign: 1bit			Exponent: 8bit								Mantissa: 23bit
//	* 
//	*		+1		*			2 ^ 1			*						1.5700000524520874 
//	*  = 2*1.5700000524520874 = 3.1400001049041748046875 = 3.14000(소수점 여섯째 자리에서 반올림)
//	* 
//	* in bin, 01000000010010001111010111000011
//	* in Hex, 0x4048f5c3
//	* 
//	* 
//	* 따라서 위의 long i를 float 형식으로 읽으면 3.14가 되는 것입니다.
//	* 애초에 i에 들어있는값이 정수형 변수로 읽으라고 만들어둔 값이 아니었다는 것을 이제 알 수 있겠죠?
//	* 
//	* 
//	* 이 테크닉을 이용해서 고정된 float 값을 더해주는 것을 최적화 해보는 것은 어떨까요?
//	* 100% 확률로 후임자에게 전화를 받으실 수 있을겁니다.
//	* 
//	* 
//	* 참고자료 :
//	*	IEEE 754
//	*	https://www.h-schmidt.net/FloatConverter/IEEE754.html
//	*	Quake 3 Arena Source Code: evil floating point bit level hacking (Wikipedia)
//	*/
//
//	cout << i << endl;
//	cout << bitFloatHack << endl;
//
//
//	return 0;
//}