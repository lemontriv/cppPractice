#include <iostream>

using namespace std;

int main()
{
	double pi_d = 3.14159265358979323846264338327950288;
	float pi_f = 3.14f;	//f안붙이면 d로 생각해서 경고뜸

	cout << pi_d << endl;//6자리 이하는 최적화함
	cout << pi_f << endl;
	cout << "------------" << endl;


	long i = 0x4048f5c3;//3.14
	float bitFloatHack = * (float *) &i;
	/*
	* &i : i의 주소
	* (float *) : 에 있는 값(비트 단위로)을 float 형식의 값으로.   long : 4바이트, float : 4바이트 -> 메모리 크기에선 문제가 발생하지 않는다.
	* * : 그 주소의 값을 저장함
	*
	* long :
	* left most bit : sign bit
	* 나머지 bit : 값을 저장하는 비트
	* 
	* float :
	*		□			   □□□□□□□□				□□□□□□□□□□□□□□□□□□□□□□□
	*  sign: 1bit		Exponent: 8bit				Mantissa: 23bit
	* 
	* 일단 이 내용을 보기만 하고 다음 내용을 읽어보자
	* 
	* 사람은 1000000000000000같은 큰 수를 간단하게 읽기 위해 다음과 같이 축약한다
	* 1.0*10^15
	* 
	* 이와 마찬가지의 방식을 컴퓨터에 적용해보자.
	* 하지만 컴퓨터는 이진수로 작동하기 때문에 십진수 체계의 지수를 사용하기 불편하다. 따라서 2^n형태로 축약하게 된다.
	* 
	* #.# * 2^#
	* 예를 들어, 2를 float로 표현한다면 다음과 같다
	* 
	*		□			   ■□□□□□□□				□□□□□□□□□□□□□□□□□□□□□□□
	*  sign: 1bit		Exponent: 8bit				Mantissa: 23bit
	* 
	* 모든 비트가 0이 아니라면, 기본적으로 1.0은 주어진다.
	* 
	* 따라서 값은 다음과 같이 표현된다.
	* 1.0 * 2^1
	* 
	* 위의 Exponent 최 좌측 비트가 1상태인 것이 보이는가?
	* Exponent도 정상적으로 우측부터 비트가 차오르긴 한다.
	* 다만, 2^-10같은 연산들도 수행하기 위해 원하는 exponent 값을 다음과 같은 방식으로 저장한다.
	* 
	* 
	* -> float의 지수부 길이 : 8 (이 값이 k)
	* -> bias = 2^(k-1)-1
	* -> bias + 원하는 exponent값  =>  bit representation
	*	-> bit representation - bias => 실제로 계산하는 exponent값
	* 
	* 따라서 2^1은 exponent 값이 1이었지만, 127 + 1 = 128이기 때문에 bit에는 최좌측(2^7 bit)만 On 된 것이다.
	* 저 bit를 컴퓨터에서 계산에 이용할 땐, 128 "- 127" = 1 이렇게 사용하게 된다.
	* 
	* 아무튼 저 exponent bit로 표현된 값에서 127을 뺀 값이 우리가 원하는 값이다.
	* 
	* 
	* 
	* 이제 3.14를 표현해보자.
	* 딱 봐도 지수부만 이용해선 어림도 없지 않은가?
	* 
	* 일단 3.14를 2의 n승으로 분리하자
	* 
	* 3.14 = 2^1 * 1.57
	* 
	* 이를 보면 sign bit : 0
	* exponent bit : 128 [1000 0000]
	* Mantissa : ???
	* 
	* 이제 1.57만 Mantissa에서 구해주면 된다.
	* Mantissa는 다음과 같이 작동한다.
	* 1.57에서 1.0은 기본으로 제공된다. (float 값의 모든 bit가 0이 아닌 이상)
	* 0.57만 따로 구한다.
	* Mantissa의 최 좌측 bit는 2^-1 = 0.5이다
	* 다음 bit는 2^-2 = 0.25이다
	* 다음은 0.125, 0.0625 ......
	* 이 값들을 조합해서 0.57과 가장 비슷한 값을 만들어야 한다.
	* 
	* 근데 좀 골때리는 문제가 있다.
	* 실제로 0.57은 만들 수 없고 그에 근접한 값만 만들 수 있다. 거기서 좀 아리까리해진다
	* 
	* 0.5700000000003
	* 0.5699999999996
	* 
	* 이 두 수 중 0.5700..003이 좋은 것이 분명하다. 왜냐하면 우리가 원하는 값이랑 더 가까우니까 근데 안해보고는 모른다.
	* 
	* 따라서 본인은 이해하려고 시도도 안한 
	* 
	*/

	cout << i << endl;
	cout << bitFloatHack << endl;


	return 0;
}